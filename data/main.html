<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sensor Data Logger</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }
        .realtime-section {
            padding: 30px;
            background: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
        }
        .realtime-title {
            text-align: center;
            font-size: 1.5em;
            color: #333;
            margin-bottom: 20px;
            font-weight: bold;
        }
        .realtime-data {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
            justify-content: center;
        }
        .realtime-card {
            background: white;
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
            border: 3px solid transparent;
        }
        .realtime-card:hover {
            transform: translateY(-5px);
        }
        .realtime-card.flowrate {
            border-color: #4CAF50;
        }
        .realtime-value {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }
        .realtime-card.flowrate .realtime-value {
            color: #4CAF50;
        }
        .realtime-label {
            color: #666;
            font-size: 1.1em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .realtime-unit {
            font-size: 0.7em;
            color: #999;
        }
        .live-indicator {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
        }
        .live-dot {
            width: 12px;
            height: 12px;
            background: #4CAF50;
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }
        .live-text {
            color: #4CAF50;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .controls {
            padding: 30px;
            background: #f8f9fa;
            display: flex;
            gap: 30px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }
        .config-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            min-width: 250px;
        }
        .config-section label {
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }
        .config-section input, .config-section select {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s ease;
        }
        .config-section input:focus, .config-section select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        .button-section {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 50px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }
        .btn-start {
            background: linear-gradient(135deg, #4CAF50, #45a049); color: white;
        }
        .btn-stop {
            background: linear-gradient(135deg, #f44336, #da190b); color: white;
        }
        .btn-export {
            background: linear-gradient(135deg, #2196F3, #1976D2); color: white;
        }
        .btn:disabled {
            opacity: 0.5; cursor: not-allowed; transform: none;
        }
        .status {
            padding: 20px 30px;
            background: #e8f5e8;
            border-left: 5px solid #4CAF50;
            margin: 0 30px;
            border-radius: 5px;
            font-weight: bold;
            text-align: center;
        }
        .status.recording {
            background: #fff3cd; border-color: #ffc107; color: #856404;
        }
        .status.stopped {
            background: #f8d7da; border-color: #dc3545; color: #721c24;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            padding: 30px;
            background: #f8f9fa;
        }
        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }
        .stat-label {
            color: #666; font-size: 0.9em; text-transform: uppercase; letter-spacing: 1px;
        }
        .data-table {
            padding: 30px; max-height: 400px; overflow-y: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        th, td {
            padding: 15px; text-align: left; border-bottom: 1px solid #ddd;
        }
        th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        tr:hover {
            background: #f5f5f5;
        }
        .progress-bar {
            margin: 20px 30px;
            background: #e0e0e0;
            border-radius: 25px;
            height: 8px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
        }
        .recording-indicator {
            display: none; align-items: center; gap: 10px; color: #dc3545; font-weight: bold;
        }
        .recording-indicator.active {
            display: flex;
        }
        .pulse {
            width: 12px; height: 12px; background: #dc3545; border-radius: 50%; animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.3; transform: scale(1.1); }
            100% { opacity: 1; transform: scale(1); }
        }
        .data-change {
            animation: dataUpdate 0.5s ease-out;
        }
        @keyframes dataUpdate {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        .sd-card-section {
            padding: 30px;
            background: #f8f9fa;
            border-top: 1px solid #e0e0e0;
        }
        .sd-card-section h2 {
            font-size: 1.5em; color: #333; margin-bottom: 15px; text-align: center;
        }
        #fileListContainer {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 8px;
            background: #fff;
            margin-bottom: 15px;
        }
        .sd-card-section ul {
            list-style: none; padding: 0; margin: 0;
        }
        .sd-card-section li {
            padding: 8px 12px; border-bottom: 1px solid #eee; cursor: pointer;
        }
        .sd-card-section li:last-child {
            border-bottom: none;
        }
        .sd-card-section li:hover {
            background-color: #f0f0f0;
        }
        .sd-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .sd-controls input[type="text"] {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 8px;
            flex-grow: 1;
        }
        .btn-sd {
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background-color: #6c757d;
            color: white;
            transition: background-color 0.3s;
        }
        .btn-sd:hover {
            background-color: #5a6268;
        }

        @media (max-width: 768px) {
            .controls { flex-direction: column; }
            .config-section { width: 100%; max-width: 300px; }
            .button-section { flex-direction: column; width: 100%; }
            .btn { width: 100%; max-width: 300px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>💧 Flow Rate Monitoring</h1>
            <p>Real-time Flow Rate and SD Card Management</p>
        </div>

        <!-- Realtime Data Display -->
        <div class="realtime-section">
            <div class="realtime-title">📊 Real-Time Sensor Data</div>
            <div class="realtime-data">
                <div class="realtime-card flowrate">
                    <div class="realtime-value" id="realtimeFlowRate">0.0</div>
                    <div class="realtime-label">Flow Rate <span class="realtime-unit">L/min</span></div>
                </div>
            </div>
            <div class="live-indicator">
                <div class="live-dot"></div>
                <div class="live-text">Live Data</div>
            </div>
        </div>

        <!-- Recording Controls Section -->
        <div class="controls">
            <div class="config-section">
                <label for="modeSelect">1. Select Mode:</label>
                <select id="modeSelect">
                    <option value="records">Fixed Number of Records</option>
                    <option value="timer">Timer Mode</option>
                </select>

                <div id="recordsMode">
                    <label for="maxRecords">2. Max Records:</label>
                    <input type="number" id="maxRecords" min="1" max="1000" value="50">
                    <label for="recordInterval">3. Interval (seconds):</label>
                    <input type="number" id="recordInterval" min="1" max="60" value="1">
                </div>

                <div id="timerMode" style="display: none;">
                    <label for="maxDuration">2. Max Duration (seconds):</label>
                    <input type="number" id="maxDuration" min="1" max="3600" value="300">
                    <label for="timerInterval">3. Interval (seconds):</label>
                    <input type="number" id="timerInterval" min="1" max="60" value="1">
                </div>
            </div>

            <div class="button-section">
                <button id="startBtn" class="btn btn-start">🚀 Start Recording</button>
                <button id="stopBtn" class="btn btn-stop" disabled>⏹️ Stop Recording</button>
                <button id="exportBtn" class="btn btn-export" disabled>📥 Export CSV</button>
                <div class="recording-indicator" id="recordingIndicator">
                    <div class="pulse"></div>
                    <span>Recording...</span>
                </div>
            </div>
        </div>

        <div class="status" id="status">
            Ready to start recording sensor data
        </div>

        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>

        <!-- Stats Section -->
        <div class="stats">
            <div class="stat-card">
                <div class="stat-value" id="recordCount">0</div>
                <div class="stat-label">Records</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="avgFlowRate">0.0</div>
                <div class="stat-label">Avg Flow Rate (L/min)</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="duration">0</div>
                <div class="stat-label">Duration (s)</div>
            </div>
        </div>

        <!-- Data Table Section -->
        <div class="data-table">
            <table>
                <thead>
                    <tr>
                        <th>Time</th>
                        <th>Flow Rate (L/min)</th>
                    </tr>
                </thead>
                <tbody id="dataTableBody">
                </tbody>
            </table>
        </div>

        <!-- SD Card Management Section -->
        <div class="sd-card-section">
            <h2>🗂️ SD Card Management</h2>
            <div id="fileListContainer">
                <ul id="fileList">
                    <li>Loading...</li>
                </ul>
            </div>
            <div class="sd-controls">
                <input type="text" id="fileNameInput" placeholder="Click file above or type name...">
                <button id="downloadFileBtn" class="btn-sd">Download</button>
                <button id="deleteFileBtn" class="btn-sd">Delete</button>
            </div>
        </div>
    </div>

    <script>
        class SensorDataLogger {
            constructor() {
                this.data = [];
                this.isRecording = false;
                this.recordingInterval = null;
                this.durationTimer = null;
                this.startTime = null;

                this.maxRecords = 50;
                this.recordInterval = 1;
                this.maxDuration = 300;
                this.timerInterval = 1;
                this.currentRecord = 0;
                this.elapsedTime = 0;
                
                this.currentFlowRate = 0;

                this.initializeElements();
                this.bindEvents();
            }

            initializeElements() {
                // Control Buttons
                this.startBtn = document.getElementById('startBtn');
                this.stopBtn = document.getElementById('stopBtn');
                this.exportBtn = document.getElementById('exportBtn');
                
                // Display Elements
                this.status = document.getElementById('status');
                this.recordingIndicator = document.getElementById('recordingIndicator');
                this.progressFill = document.getElementById('progressFill');
                this.dataTableBody = document.getElementById('dataTableBody');
                
                // Stats
                this.recordCount = document.getElementById('recordCount');
                this.avgFlowRate = document.getElementById('avgFlowRate');
                this.duration = document.getElementById('duration');

                // Realtime display
                this.realtimeFlowRate = document.getElementById('realtimeFlowRate');

                // Config inputs
                this.maxRecordsInput = document.getElementById('maxRecords');
                this.recordIntervalInput = document.getElementById('recordInterval');
                this.maxDurationInput = document.getElementById('maxDuration');
                this.timerIntervalInput = document.getElementById('timerInterval');
                this.modeSelect = document.getElementById('modeSelect');
                this.recordsMode = document.getElementById('recordsMode');
                this.timerMode = document.getElementById('timerMode');
            }

            bindEvents() {
                this.startBtn.addEventListener('click', () => this.startRecording());
                this.stopBtn.addEventListener('click', () => this.stopRecording());
                this.exportBtn.addEventListener('click', () => this.exportToCSV());

                this.modeSelect.addEventListener('change', (e) => {
                    if (e.target.value === 'records') {
                        this.recordsMode.style.display = 'block';
                        this.timerMode.style.display = 'none';
                    } else {
                        this.recordsMode.style.display = 'none';
                        this.timerMode.style.display = 'block';
                    }
                });
            }

            updateRealtimeDisplay(flowRate) {
                this.realtimeFlowRate.classList.add('data-change');
                this.realtimeFlowRate.textContent = flowRate.toFixed(1);
                setTimeout(() => {
                    this.realtimeFlowRate.classList.remove('data-change');
                }, 500);
            }

            getCurrentTime() {
                return new Date().toLocaleTimeString();
            }

            startRecording() {
                this.maxRecords = parseInt(this.maxRecordsInput.value);
                this.recordInterval = parseFloat(this.recordIntervalInput.value);
                this.maxDuration = parseInt(this.maxDurationInput.value);
                this.timerInterval = parseFloat(this.timerIntervalInput.value);

                this.data = [];
                this.currentRecord = 0;
                this.elapsedTime = 0;
                this.isRecording = true;
                this.startTime = Date.now();

                this.startBtn.disabled = true;
                this.stopBtn.disabled = false;
                this.exportBtn.disabled = true;

                const mode = this.modeSelect.value;
                this.status.textContent = mode === 'records'
                    ? `Recording... (Max: ${this.maxRecords} records, Interval: ${this.recordInterval}s)`
                    : `Recording... (Max: ${this.maxDuration}s, Interval: ${this.timerInterval}s)`;
                
                this.status.className = 'status recording';
                this.recordingIndicator.classList.add('active');

                this.dataTableBody.innerHTML = '';
                this.updateStats();
                this.updateProgressDisplay();

                if (mode === 'records') {
                    this.recordingInterval = setInterval(() => this.recordData(), this.recordInterval * 1000);
                } else {
                    this.recordingInterval = setInterval(() => this.recordData(), this.timerInterval * 1000);
                    this.durationTimer = setInterval(() => {
                        this.elapsedTime++;
                        this.updateStats();
                        this.updateProgressDisplay();
                        if (this.elapsedTime >= this.maxDuration) {
                            this.stopRecording('Maximum duration reached');
                        }
                    }, 1000);
                }
            }

            recordData() {
                if (this.modeSelect.value === 'records' && this.currentRecord >= this.maxRecords) {
                    this.stopRecording('Maximum records reached');
                    return;
                }

                const record = {
                    time: this.getCurrentTime(),
                    flowRate: parseFloat(this.currentFlowRate.toFixed(2))
                };

                this.data.push(record);
                this.currentRecord++;

                this.addTableRow(record);
                this.updateStats();
                this.updateProgressDisplay();

                if (this.modeSelect.value === 'records') {
                    this.elapsedTime = Math.floor((Date.now() - this.startTime) / 1000);
                }
            }

            addTableRow(record) {
                const row = document.createElement('tr');
                row.innerHTML = `<td>${record.time}</td><td>${record.flowRate.toFixed(2)}</td>`;
                this.dataTableBody.insertBefore(row, this.dataTableBody.firstChild);
            }

            updateStats() {
                const recordCountVal = this.data.length;
                this.recordCount.textContent = recordCountVal;

                if (recordCountVal > 0) {
                    const totalFlow = this.data.reduce((sum, record) => sum + record.flowRate, 0);
                    this.avgFlowRate.textContent = (totalFlow / recordCountVal).toFixed(2);
                } else {
                    this.avgFlowRate.textContent = '0.0';
                }
                this.duration.textContent = this.elapsedTime;
            }

            updateProgressDisplay() {
                const mode = this.modeSelect.value;
                const progress = mode === 'records'
                    ? (this.currentRecord / this.maxRecords) * 100
                    : (this.elapsedTime / this.maxDuration) * 100;
                this.progressFill.style.width = `${Math.min(progress, 100)}%`;
            }

            stopRecording(reason = 'Recording stopped manually') {
                this.isRecording = false;
                clearInterval(this.recordingInterval);
                clearInterval(this.durationTimer);
                this.recordingInterval = null;
                this.durationTimer = null;

                this.startBtn.disabled = false;
                this.stopBtn.disabled = true;
                this.exportBtn.disabled = this.data.length === 0;

                this.status.textContent = `${reason}. ${this.data.length} records collected in ${this.elapsedTime}s.`;
                this.status.className = 'status stopped';
                this.recordingIndicator.classList.remove('active');
                this.updateStats();
            }

            exportToCSV() {
                if (this.data.length === 0) {
                    alert('No data to export!');
                    return;
                }

                const csvHeader = 'Time,Flow Rate (L/min)\n';
                const csvData = this.data.map(r => `${r.time},${r.flowRate}`).join('\n');
                const blob = new Blob([csvHeader + csvData], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `flow_data_${new Date().toISOString().slice(0, 10)}.csv`;
                a.click();
                window.URL.revokeObjectURL(url);

                this.status.textContent = 'Data exported successfully!';
                this.status.className = 'status';
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const logger = new SensorDataLogger();

            // --- Sensor Data Fetching ---
            function getSensorData() {
                fetch('/data')
                    .then(response => {
                        if (!response.ok) throw new Error('Network response was not ok');
                        return response.json();
                    })
                    .then(data => {
                        if (data.hasOwnProperty('flow_rate')) {
                            logger.currentFlowRate = data.flow_rate;
                            logger.updateRealtimeDisplay(data.flow_rate);
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching sensor data:', error);
                        logger.updateRealtimeDisplay(0); // Show 0 on error
                        document.getElementById('realtimeFlowRate').textContent = 'Error';
                    });
            }
            setInterval(getSensorData, 100); // Fetch every 2 seconds
            getSensorData(); // Initial fetch

            // --- SD Card Management Functions ---
            const fileListElem = document.getElementById('fileList');
            const fileNameInput = document.getElementById('fileNameInput');

            function listFiles() {
                fetch('/list_files')
                    .then(response => {
                        if (response.status === 503) { // Service Unavailable (SD not ready)
                            fileListElem.innerHTML = '<li>SD Card not available.</li>';
                            throw new Error('SD Card not available');
                        }
                        if (!response.ok) throw new Error('Failed to list files');
                        return response.json();
                    })
                    .then(files => {
                        fileListElem.innerHTML = '';
                        if (files.length === 0) {
                            fileListElem.innerHTML = '<li>No .csv files found.</li>';
                        } else {
                            files.forEach(file => {
                                const li = document.createElement('li');
                                li.textContent = file;
                                li.onclick = () => { fileNameInput.value = file; };
                                fileListElem.appendChild(li);
                            });
                        }
                    })
                    .catch(error => {
                        console.error('Error listing files:', error.message);
                        if (error.message !== 'SD Card not available') {
                           fileListElem.innerHTML = '<li>Error loading file list.</li>';
                        }
                    });
            }

            function deleteFile() {
                const filename = fileNameInput.value;
                if (!filename) { alert('Please select or enter a filename to delete.'); return; }
                if (!confirm(`Are you sure you want to delete ${filename}?`)) return;

                fetch(`/delete_file?filename=${filename}`)
                    .then(response => {
                        if (!response.ok) throw new Error('Server responded with an error.');
                        alert('File deleted successfully');
                        fileNameInput.value = '';
                        listFiles();
                    })
                    .catch(error => {
                        console.error('Error deleting file:', error);
                        alert('Error deleting file. Check console for details.');
                    });
            }

            function downloadFile() {
                const filename = fileNameInput.value;
                if (!filename) { alert('Please select or enter a filename to download.'); return; }
                window.location.href = `/download_file?filename=${filename}`;
            }

            document.getElementById('deleteFileBtn').addEventListener('click', deleteFile);
            document.getElementById('downloadFileBtn').addEventListener('click', downloadFile);

            listFiles();
        });
    </script>
</body>
</html>